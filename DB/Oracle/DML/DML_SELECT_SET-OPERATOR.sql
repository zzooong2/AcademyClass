--SET OPERATOR(집합 연산자): UNION, UNION ALL, INTERSCT, MINUS
--UNION: 두개의 쿼리문에 대한 수행결과를 더하고 중복 제거 
SELECT
	DEPARTMENT_ID,
	FIRST_NAME,
	SALARY,
	EMPLOYEE_ID
FROM
	EMPLOYEES e
WHERE
	DEPARTMENT_ID = 80
	
UNION 

SELECT
	DEPARTMENT_ID,
	FIRST_NAME,
	SALARY,
	EMPLOYEE_ID
FROM
	EMPLOYEES e
WHERE
	SALARY >= 10000;

--데이터 조회에 대한 컬럼명은 선행 쿼리문에 의해 결정됨
--DEPARTMENT_NAME은 FIRST_NAME 컬럼의 결과값으로 더해짐
--TO_CHAR(): 데이터타입 동일하게 설정
SELECT
	FIRST_NAME,
	LAST_NAME,
	MANAGER_ID
FROM
	EMPLOYEES e

UNION

SELECT
	DEPARTMENT_NAME,
	TO_CHAR(LOCATION_ID),
	MANAGER_ID
FROM
	DEPARTMENTS d;


--UNION ALL: UNION과 동일한 동작을 하지만 중복제거를 안함
SELECT
	FIRST_NAME,
	LAST_NAME,
	SALARY
FROM
	EMPLOYEES e
WHERE
	SALARY BETWEEN 5000 AND 10000

UNION ALL

SELECT
	FIRST_NAME,
	LAST_NAME,
	SALARY
FROM
	EMPLOYEES e
WHERE
	FIRST_NAME LIKE 'A%'
ORDER BY FIRST_NAME;


--INTERSECT: 교집합 (AND 연산)
SELECT
	FIRST_NAME,
	LAST_NAME,
	SALARY
FROM
	EMPLOYEES e
WHERE
	SALARY BETWEEN 5000 AND 10000

INTERSECT

SELECT
	FIRST_NAME,
	LAST_NAME,
	SALARY
FROM
	EMPLOYEES e
WHERE
	FIRST_NAME LIKE 'A%'
ORDER BY FIRST_NAME;


--MINUS: 선행 쿼리문의 결과에서 후행 쿼리문의 결과값을 모두 제외
SELECT
	FIRST_NAME,
	LAST_NAME,
	SALARY
FROM
	EMPLOYEES e
WHERE
	SALARY BETWEEN 5000 AND 10000

MINUS

SELECT
	FIRST_NAME,
	LAST_NAME,
	SALARY
FROM
	EMPLOYEES e
WHERE
	FIRST_NAME LIKE 'A%'
ORDER BY FIRST_NAME;


------------------------------------------------------------

--연습예제

--1. EMPLOYEES 테이블에서 MANAGE_ID가 108이면서 월급이 800 이상인 직원의 데이터를 조회하되, 중복이 되는 값을 제거하고 조회하세요.
SELECT
	FIRST_NAME || ' ' || LAST_NAME
FROM
	EMPLOYEES e
WHERE
	MANAGER_ID = 108

UNION

SELECT
	FIRST_NAME || ' ' || LAST_NAME
FROM
	EMPLOYEES e
WHERE
	SALARY >= 8000;

--2. EMPLOYEES와 DEPARTMENTS 테이블에서 DEPARTMENT_ID, MANAGER_ID가 중복되는 데이터를 조회하세요.
SELECT
	DEPARTMENT_ID,
	MANAGER_ID
FROM
	EMPLOYEES e
WHERE
	DEPARTMENT_ID IS NOT NULL

INTERSECT

SELECT
	DEPARTMENT_ID,
	MANAGER_ID
FROM
	DEPARTMENTS d
WHERE
	MANAGER_ID IS NOT NULL;